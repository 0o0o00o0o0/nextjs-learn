{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport WithDva from \"./store\";\nexport const WithComponent = (Components, initData) => {\n  Components.getInitialProps = async props => {\n    const {\n      pathname,\n      query,\n      isServer,\n      store\n    } = props; // await props.store.dispatch({ type: 'index/init' });\n\n    let result = {};\n\n    if (initData) {\n      result = await initData();\n    }\n\n    return _objectSpread({\n      pathname,\n      query,\n      isServer,\n      dvaStore: store\n    }, result);\n  };\n\n  return WithDva(state => ({\n    index: state.index\n  }))(Components);\n};","map":{"version":3,"sources":["E:/zsDir/nextjs-learn/utils/commonsStore.ts"],"names":["WithDva","WithComponent","Components","initData","getInitialProps","props","pathname","query","isServer","store","result","dvaStore","state","index"],"mappings":";;;;;;AAAA,OAAOA,OAAP;AACA,OAAO,MAAMC,aAAa,GAAG,CAACC,UAAD,EAS1BC,QAT0B,KASoD;AAC7ED,EAAAA,UAAU,CAACE,eAAX,GAA6B,MAAOC,KAAP,IAAiB;AAC1C,UAAM;AACFC,MAAAA,QADE;AACQC,MAAAA,KADR;AACeC,MAAAA,QADf;AACyBC,MAAAA;AADzB,QAEFJ,KAFJ,CAD0C,CAI1C;;AACA,QAAIK,MAA8B,GAAG,EAArC;;AACA,QAAIP,QAAJ,EAAc;AACVO,MAAAA,MAAM,GAAG,MAAMP,QAAQ,EAAvB;AACH;;AACD;AACIG,MAAAA,QADJ;AACcC,MAAAA,KADd;AACqBC,MAAAA,QADrB;AAC+BG,MAAAA,QAAQ,EAAEF;AADzC,OACmDC,MADnD;AAGH,GAZD;;AAaA,SAAOV,OAAO,CAAEY,KAAD,KAAY;AAAEC,IAAAA,KAAK,EAAED,KAAK,CAACC;AAAf,GAAZ,CAAD,CAAP,CAA6CX,UAA7C,CAAP;AACH,CAxBM","sourcesContent":["import WithDva from './store';\r\nexport const WithComponent = (Components: {\r\n    (props: any): JSX.Element;\r\n    getInitialProps?: (props: any) => Promise<{\r\n        [key: string]: any;\r\n        pathname: any;\r\n        query: any;\r\n        isServer: any;\r\n        dvaStore: any;\r\n    }>\r\n}, initData?: () => Promise<{ [key: string]: any }> | { [key: string]: any }) => {\r\n    Components.getInitialProps = async (props) => {\r\n        const {\r\n            pathname, query, isServer, store,\r\n        } = props;\r\n        // await props.store.dispatch({ type: 'index/init' });\r\n        let result: { [key: string]: any } = {};\r\n        if (initData) {\r\n            result = await initData();\r\n        }\r\n        return {\r\n            pathname, query, isServer, dvaStore: store, ...result\r\n        };\r\n    };\r\n    return WithDva((state) => ({ index: state.index }))(Components)\r\n}"]},"metadata":{},"sourceType":"module"}